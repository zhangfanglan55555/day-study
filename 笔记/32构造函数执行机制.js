// 图在有道云
function fn() { }
fn();
/**
 * [普通函数执行]：
 * 1.形成一个私有作用域
 * 2.形参赋值
 * 3.变量提升
 * 4.代码执行
 * 5.栈内存释放
 */



function Fn(name, age) {
    var n = 10;
    this.name = name;
    this.age = age + n;

}

 /** 
 * [构造函数执行]：
 * 1.像普通函数执行一样，形成一个私有作用域（栈内存）
 *  - 形参赋值（私有变量）
 *  - 变量提升（私有变量）
 * 2.[构造函数独有的]：js代码自上而下执行之前，首先在当前形成的私有栈中创建一个对象（创建一个堆内存：暂时不储存任何东西）并且
 *                让函数中的执行主体(THIS)指向这个新的堆内存（THIS===创建的对象）
 * 3.代码自上而下执行
 * 4.[构造函数独有的]代码执行完，把之前创建的堆内存地址返回（浏览器默认返回）
 * 
 * 
 * 也就是开始创建的对象其实就是当前Fn这个类的一个实例，我们让那个this指向这个实例，代码中执行this.xxx = xxx;都是给实例设置“私有属性”
 * 最后浏览器会把默认创建的实例返回，供外面接收
 * 
 * 再次执行new Fn就是把上面的操作克隆一份，会形成新的实例（内存空间）所以实例都是独立分开的。
 */
var f1 = new Fn('xxx',20);
var f2 = new Fn('aaa',30);

console.log(f1 === f2);//false :两个不同的堆内存地址
console.log(f1.age);//30
console.log(f2.name);//aaa
console.log("name" in f1);//true  namge&age在两个不同的实例中都有存储，但都是每个实例自己的私有属性
console.log(f1.n);//undefined  只有this.xxx =xx 才和实例有关系，n是私有作用域中的一个私有变量而已（this是当前类的实例）


