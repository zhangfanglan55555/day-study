## GIT : 分布式版本控制系统

### 1.版本控制系统

       开发中我们每一次的修改都有效的进行记录（记录成一个版本），后期如果需要后退到原有的有个版本或者用当前的和某一个版本进行比较等，都可以有效的进行管理
       常用的版本控制系统：SVN(集中式)、GET(分布式)

### 2.分布式版本管理系统的特点
团队协作开发

1.基础流程操作
 1）首先创建中央仓库:可以基于gitHub/codding来创建（最好不要创建空仓库，因为空仓库中没有任何分支，只有提交一次历史信息才会生成MASTER分支）
   http://github.com/

   把开发者都列入仓库的开发群组中，这样每一个开发者用自己的gitHub账号，都有权限操作这个仓库了（当然不这样做也可以，所有开发者用统一的一个账号也可以，为了防止不知道是谁提交的，我们需要让每一个客户端在本地的GIT全局配置中，设置和gitHub相同的用户名和邮箱 $ git config --global user.name 'xxx' ...）

 2）创建客户端本地仓库（一个开发者就是一个单独仓库），还需要让本地的仓库和远程仓库保持关联，这样才可以实现后续的信息同步
   $ git init    =>创建本地仓库
   $ git remote add origin “远程仓库GIT地址”   =>让本地仓库和远程仓库保持连接
   $ git remote -v    =>查看连接信息（origin是连接的名称，一般都用这个名字，当然自己可以随便设置）
   $ git remote rm origin     =>移除本地仓库和远程仓库的链接
   $ git remote update origin   =>更新链接通道

   有更简单的方式：只要把远程仓库克隆到本地，就相当于创建本地仓库，而且自动建立了链接，并且把远程仓库中的内容也同步到了本地
   $ git clone “远程仓库地址” “本地仓库文件夹名字（不写默认是仓库名字）”


 3）各自和中央服务器同步信息
   推送：$ git push origin master   （每一次PUSH之前最好都PULL一下：如果有冲突在本地处理一下冲突，然后再推送）
   拉取：$ git pull origin master

======================
知识点：
  $ git clone “远程仓库地址”   把远程仓库克隆到本地（本地自动和远程建立连接，自动把远程中的信息同步到本地了，本地也是一个单独的仓库：建议远程仓库不要是空的，至少有一个master分支）

  $ git pull origin master  把远程仓库MASTER中的信息同步到本地仓库MASTER中

  $ git push origin master  把本地仓库MASTER中的信息同步到远程仓库MASTER中（需要使用gitHub的用户密码来进行权限校验：一般都是组长在远程仓库中把组员的账号都放到小组中，这样组员用自己的账号也有权限操作仓库了，最好在本地的GIT配置中把用户名和邮箱修改为和gitHub账号相同的信息）

  如果有冲突：
     1.进入到了编辑框模式，i->ESC->:wq 即可
     2.自己会把两份代码都保存在本地文件中，自己手动去选择要哪一个，改完后重新提交即可

  $ git checkout -b xxx  创建分支并且切换到指定分支下（可以把本地master中的历史信息同步到新创建的分支中）
    git branch
    git branch xxx
    git checkout xxx
    git branch -D xxx 删除分支

  $ git merge xxx  把xxx分支的历史信息合并到当前分支下

  $ git stash / $ git stash pop  在切换分支的时候，有一部分信息并没有提交成为历史版本，为了防止信息的丢失，我们需要先使用stash保存，然后在基于stash pop还原
=======

          所谓分布式，就是每个开发者的本地客户端都是一个完整的仓库，都能记录历史版本信息，这样不需要联网我们也能生成版本记录，也可以快速回退到某个版本
          Git是按照源数据（文件流）来实现文件传输的，而SVN是按照文件传输的，所以git比SVN更快

### 3.Linux 团队开发的 GIT，所以 GIT 中的命令大部分都是 LINUX 命令

======

### Linux 常用的操作命令

```
 ls -a/-l ： 查看当前目录结构（-a是可以看见所有的包括隐藏文）
 cd xxx[路径地址]  : 进入到指定的文件夹
    cd / : 根目录
    cd ./ : 当前目录
    cd ../:上级目录
 clear : 清屏
 mkdir : 创建文件夹
 touch : 创建空的文件
 vi    : 向文件中插入或者管理一些内容
    i : 进入到插入模式
    esc + :wq ,: 退出内容的插入模式，把刚才编辑的内容进行保存
 echo : 向指定的文件中输入内容,覆盖型的
    echo 哈哈哈 > 3.txt
 cat : 查看文件中的内容
 cp : 拷贝
 rm: 删除文件  -r(递归删除) -f（强制删除)，一旦删除无法还原
    rm -rf
```

### GIT 工作流程及常用命令

#### git 的常规流程

##### 1.每一个 GIT 仓库都有三个区

        工作区： 写代码的
        暂存区：临时存放每一次修改的代码，但是并没有生成历史版本
        历史区：存放所有历史版本的地方（提交到历史区就会生成历史版本）

```
创建git仓库： $ git init
            $ git add -A / . 把当前工作区修改的内容全部提交到暂存区（可以指定具体提交的文件 $ git add xxx.js）
            $ git commit -m '备注' 把暂存区中的内容提交到历史区，生成一个历史版本（我们需要些备注信息，声明当前版本的特点）
    每一次区域间信息的提交都不会删除原有区域中的内容，这样保证下一次提交，只是把区域对比出来不一样的内容提交而不是所有的
            $ git status 查看当前修改的文件处于哪一个区域，
                    红色：代表在工作区
                    绿色：暂存区
                    看不见：已经提交到历史区，三区保持一致了
            $ git rm --cached <file> ... 撤回提交
```

#### 2. 把暂存区的某一个文件删除（提交到暂存区内容不好，我们可以删除）

    $ git rm --cached xxx.xx 把暂存区的某一个文件删除
    $ git rm --cached xxx.xx -f 强制把暂存区的某一个文件删除
    $ git rm --cached . -r 删除暂存区中所有提交

    如果在删除过程中，发现从暂存区撤销的文件，在工作区已经被修改了，只有加上-f才能强制从暂存区把内容删除掉

#### 3.提交到暂存区一份，把工作区内容改了，但是改的东西不好，想把暂存区上次提交的内容撤回到工作区（覆盖工作区信息的内容）

```
    $ git checkout xxx.xx
    暂存区内容没有消失，只是把工作区最新修改的信息给覆盖了，让工作区和暂存区保持一致
```

#### 4.查看文件 diff

```
    $ git diff <file> 比较工作区和暂存区文件差异
    $ git diff
```

### 一些细节问题

````
    1.如果是第一次使用git，生成历史版本的时候，需要提供身份认证
      $ git config -l 查看当前git配置
      $ git config --global user.name 'xxx'
      $ git config --global user.email 'xxx@xxx'
    2.真实项目中，并不是所有的问题都和项目有关系（例如.idea是ws生成的配置文件夹和项目没关系)，也不是所有的文件都提交（例如
    node_modules中的内容太大了，也不需要提交)
    .gitignore =》 git提交的忽略文件
     ```
        /node_modules
        /build
     ```
     $ Git log：查看最近到最远提交到仓库的文件信息（一串数字为特有的时间序列id 可以根据它进行版本前后回滚）
     $ git reflog 查看所有的历史记录
     $
````

    代码回滚操作
        $ git checkout . 把暂存区内容回滚到工作区，一旦回滚，工作区内容无法恢复
        $ git reset HEAD . 把最近暂存区中的内容删除掉，目的是可以用git checkout . 可以把上一个暂存区回滚到工作区
        $ git reset --hard 版本号 强制把暂存区和工作区都变成历史区中的某个版本
        $ history > xxx.txt 把历史操作步骤输出

    团队协作模式
    1.创建中央仓库
        $ git clone /$ git remote add /rm/-v xxx xxx/git
    2.团队成员克隆岛本地，形成本地仓库(Leader也可以在远程仓库中增加团队成员的权限)

    $ git push origin master 把本地历史区中的信息推送到中央服务器上

团队协作开发： 1.基础流程操作
1） 首先创建中央仓库：可以基于 gitHub/codding 来创建
$ git init 
$ git remote add origin "远程仓库 git 地址“让本地仓库和远程仓库保持连接
$ git remote -v 查看连接信息（origin是连接的名称，一般都用这个名字，当然自己可以随便设置)
$ git remote update origin 更新连接通道

---

有更简单的方式：只要把远程仓库克隆到本地，就相当于创建本地仓库，而且自动建立了连接，并且把原程仓库中的内容也
同步到了本地
\$ git clone "远程仓库地址" "本地仓库文件夹的名字（不写默认是仓库名）“

解决冲突：
文件有冲突，但是不是同一个文件同一行代码
i ->esc->:wq 安下 enter 即可然后提交
文件有冲突，是同一行冲突
\$ merge conflict in readme.md

$ git checkout -b xxx 创建分支并且切换到指定分支下（可以把本地master中的历史信息同步到新创建的分支中）
$ git branch -D xxx 删除分支
$ git merge xxx 把 xxx 分支的历史信息合并到当前分支下
$ git stash 
