/**
 * [事件的传播机制]
 *      冒泡传播：触发当前元素的某一个(点击事件)事件行为，不仅当前元素事件行为触发，而且其祖先元素
 *              的相关事件也会依次被触发，这种机制就是”事件的冒泡传播机制"。
 *              跟结构有关跟定位无关
 */
window.onclick = function () {
    // 给window绑定方法
}
document.onclick = function () {
    // 给document绑定方法
}
document.documentElement.onclick = function () {
    // 给html绑定方法
}

document.body.onclick = function () {
    // 给body绑定方法
}

outer.onclick = function () {
    // 给outer绑定方法
}
inner.onclick = function (ev) {
    // 给inner绑定方法
    ev = ev || window.event;
    // ev.path : 捕获阶段规划路径
}
/**
 * 1-[捕获阶段] ：
 * 点击INNER的时候，首先会从最外层开始向内查找(找到操作的事件源)，查找的目的是，
 * 构建出冒泡传播阶段需要传播的路线(查找就是按照HTML层级结构找的)
 * 2-[目标阶段]
 *  把事件源的相关操作行为触发(如果绑定了方法，则把方法执行)
 * 3-[冒泡传播]
 *  按照捕获阶段规划的路线，自内而外，把当前事件源的祖先元素的相关实践行为依次触发(如果某一个祖先元素事件行为绑定了方法，则把
 *  方法执行，没绑定方法，行为出发了，什么都不做，继续向上传播即可)
 * [在Event.prototype上]：
 *  0 : NONE 什么都没做呢，初始阶段
 *  1 : CAPTURING_PHASE 捕获阶段
 *  2 : AT_TARGET 事件源 目标阶段
 *  3 : BUBBLING_PHASE 冒泡阶段
 * 
 * xxx.onclick = function(){} DOM0事件绑定，给元素的事件行为绑定方法，这些方法都是在当前
 * 元素事件行为的冒泡阶段（或者目标阶段）执行的
 * xxx.addEventListener('xxx',function(){},false)  第三个参数false也是控制绑定的方法在事件传播的冒泡阶段
 * 或者目标阶段执行；只有第三个参数为true才代表让当前方法在事件传播的捕获阶段触发执行（这种捕获阶段执行 没啥实际意义，项目
 * 中不用）
 * 
 * 
 *  不同浏览器对于最外层祖先元素的定义是不一样的
 *  谷歌：window-> document->html->body...
 *  IE高：window->html->body...
 *  IE低: html->body...
 * 
 * [关于事件对象的一些理解]
 *  1.事件对象是用来存储当前本次操作的的相关信息的，和操作有关，和元素无必然关联
 *  2.当我们基于鼠标或者键盘等操作的时候，浏览器会把本次操作的信息存储起来（标准浏览器存储到默认的
 *    内存中[自己找不到]，IE低版本存储到window.event中了），存储的值是一个对象（堆内存）；操作
 *    肯定会触发元素的某个行为，把绑定的方法执行，此时标准浏览器会把之前存储的对象（准确来说是堆内存
 *    地址）当做实参传递给每一个执行的方法，所以操作依次，即使再多方法中都有ev，但是存储的值都是一个
 *    本次操作信息的对象
 */