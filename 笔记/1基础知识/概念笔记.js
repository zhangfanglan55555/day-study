/**
 * 栈内存&堆内存
 * 栈内存：作用域
 * 1、提供一个供JS代码自上而下执行的环境（代码都是在栈中执行的）
 * 2、由于基本数据类型比较简单，都是直接在栈内存中开辟一个位置，把值直接存进去的。
 *    =》 当栈内存被销毁，存储的那些基本值也都跟着销毁了。
 *        栈内存如何销毁？
 * 堆内存：引用值对应的空间
 * 作用：1、存储引用类型值的（对象：键值对，函数：代码字符串）
 *      =》当前堆内存释放（销毁），那么这个引用值彻底没了；
 *      堆内存如何释放？
 *         当堆内存没有被任何的变量或者其他的东西所占用，浏览器会在空闲的时候自主进行内存回收，把所有不被占用的堆内存销毁掉（谷歌浏览器）
 *         xxx = null;通过空指针可以让原始变量（或其他东西）谁都不指向，那么原有被占用的堆内存就没有被占用了，浏览器会销毁他
 * 
 * 变量提升:当栈内存（作用域）形成JS代码自上而下执行之前，浏览器首先会把所有的带var 和function 关键字的进行提前的声明或者定义。（这种预先处理机制就是变量提升
 *          =》 声明（declare):var a;或者function sum 默认值都是undefined
 *          =》 定义（defined):a = 12; 定义就是赋值
 *          “变量提升阶段”
 *            =》 带“var"的 只声明不定义
 *            =》 带“function” 的 既声明又定义
 *          变量提升只发生在当前作用域 ：
 *            例如：开始加载页面的时候只对全局作用域下的进行提升，因此此时函数中存储的都是字符串而已
 *                 在全局作用域下声明的变量或者函数是“全局变量”，同理，在私有作用域下声明的变量是“私有变量”
 *          浏览器做过的事情不会重复执行第二遍，也就是当代码执行遇到创建函数这部分代码后，直接跳过即可（因为在提升阶段已经完成函数
 *              的赋值操作了。
 *          私有的栈内存：
 *              私有作用域形成后，也不是立即代码执行，而是先进行变量提升（变量提升前，先形参赋值）：形参赋值、变量提升、代码执行
 *              在es3\es5语法规范中，只有全局作用域和函数执行的私有作用域（栈内存），其他大括号不会形成栈内存；
 * 
 *        只对等号左边的进行变量提升：
 *              变量提升：var fn;当作普通变量处理，默认值是undefined;sum是function 既声明又定义
 *              fn();//fn is not a function
 *              var fn = function(){}//匿名函数表达式
 *              function sum(){}//普通函数
 *              开发中推荐使用函数表达式，因为函数表达式必须先创建再执行。
 *        条件判断下的变量提升：
 *              if(1==2){   
 *                  var a = 13;        
 *              }
 *              在当前作用域下，不管条件是否成立都要进行变量提升；
 *                  带var的还是只声明
 *                  带function的在老版本的浏览器渲染机制下，声明+定义都处理，但是为了迎合es6中的块级作用域，新版本浏览器(chrome四十几的)
 *                  只声明不定义，类似于var;
 * 
 *              在全局作用域下声明的全局变量也相当于给win设置了一个属性window.a = undefined;
 *              console.log(a);//undefined
 *              if('a' in window){
 *                  var a = 100;
 *              }
 *              console.log(a);//100
            /**
             * !的运算级高于==,先计算![],!可以将变量转为boolean型的，null、undefined、NaN以及空串("")取反都是true，其余为false
             * ![] 的结果是false,!{} fasle
             * [] == false,会自动进行类型转换，[] 为false转换为0,0==0;//true
             * {}.toString()//返回的是NaN, 如果有一个操作数是NaN，则相等操作符返回 false
             * 
             * 
             */
            /**
             * == 先转换再比较
             * === 仅比较不转换
             * ==：
             *      相等操作符会先转换操作数（通常称为强制转型），然后比较它们的相等性。

                    在转换不同的数据类型时，相等操作符遵循下列基本规则：

                    1. 如果有一个操作数是布尔值，则在比较相等性之前，将其转换为数值；

                    2. 如果一个操作数是字符串，另一个操作数是数值，在比较之前先将字符串转换为数值；

                    3. 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法，用得到的基本类型值按照前面的规则进行比较；

                    4. 如果有一个操作数是 NaN，无论另一个操作数是什么，相等操作符都返回 false；

                    5. 如果两个操作数都是对象，则比较它们是不是同一个对象。如果指向同一个对象，则相等操作符返回 true；

                    6. 在比较相等性之前，不能将 null 和 undefined 转成其他值。

                    7. null 和 undefined 是相等的。 
            {} 和 [] 都是存放在栈内存中开辟的堆内存的，在使用== 操作符的时候比较的是堆内存的地址而不是真实的值   
          
          
            {} == !{} false
                !运算优先级高于== ，!{}=> false ，表达式变为：{} == false
                第一条规则，如果一个操作数是布尔值，则在比较相等性之前，将其转为数值 {} == 0
                Number({}) => NaN 应用第4条，如果一个操作数为NaN返回false
            [] == ![] true 
                !运算符优先级高于==, ![] => false，表达式变为：[] == false
                第一条规则如果一个操作数是布尔值，则在比较相等性之前，将其转为数值 [] == 0
                Number([]) => 空数组返回 0,表达式变为 0 == 0;=> 0 == 0 => true

            Number()规则：
                1）如果是Boolean值，true和false将分别转换为1和0。

                2）如果是数字值，只是简单的传入和返回。

                3）如果是null值，返回0。

                4）如果是undefined,返回NaN。

                5）如果是对象，返回NaN

                6) 如果是数组，非空返回NaN，空数组返回0
            */


/**
 * 
 *  * JS中内存分为堆内存和栈内存：
 * 堆内存：存储引用数据类型地址（对象：键值对，函数：代码字符串）
 * 栈内存：提供JS代码执行的环境和存储基本类型值
 * 
 * [堆内存释放]：
 *          让所有引用堆内存空间地址的变量赋值为null即可（没有变量占用这个堆内存了，浏览器会在空闲时，把它释放掉）
 * [栈内存释放]：
 *        一般情况下当函数执行完成，所形成的私有作用域（栈内存）都会自动释放。在栈内存中存储的基本值也都会释放，
 *       但是也有特殊不销毁的：
          1、函数执行完成，当前形成的栈内存中，某些内容被栈内存以外的变量占用，此时栈内存不能释放。（一旦释放，外面找不到原有内容）
 *        2、全局栈内存只有在页面关闭的时候才会被释放
 *  
 *      如果当前栈内存没有释放，那么之前在栈内存中存储的基本类型值也不会被释放，能够一直保存下来
 * 
 * 
 * [ macrotasks ] : setTimeout, setInterval, setImmediate, I/O, UI rendering
   [ microtasks ]: process.nextTick, Promise, MutationObserver


   如果某个microtask任务被推入到执行中，那么当主线程任务执行完成后，
   会循环调用该队列任务中的下一个任务来执行，直到该任务队列到最后一个任务为止。
   而事件循环每次只会入栈一个macrotask,
   主线程执行完成该任务后又会检查microtasks队列并完成里面的所有任务后再执行macrotask的任务。
 *  */   