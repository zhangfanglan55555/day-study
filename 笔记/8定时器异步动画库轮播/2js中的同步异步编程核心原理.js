/**
 * js中的同步编程和异步编程
 *   同步编程：任务是按照顺序依次处理，当前这件事没有彻底做完，下一件事是执行不了的
 * 异步编程：当前这件事没有彻底做完，需要等待一段时间才能继续处理，此时我们不等，继续执行下面的任务，当后面的
 * 任务完成后，再去把没有彻底完成的事情完成
 * [js中的异步编程]
 *  1.所有的事件绑定都是异步编程  xxx.onclick = function(){}
 *  2.所有的定时器都是异步编程 setTimeout(function(){},1000)
 *  3.ajax中一般都是使用异步编程处理
 *  4.回调函数也算是异步编程
 *  ......
 */
let n = 0;
setTimeout(() => {
    console.log(++n);//1
}, 1000)
console.log(n);//0




let n = 0;
setTimeout(() => {
    console.log(++n)
}, 1000);
console.log(n);
while (1 === 1) {
    // 死循环
}
/**
 * 输出0
 * 定时器设定一个时间，到达时间后也不一定执行（如果当前
 * 还有其他同步任务正在处理，那么到时间也得等着）
 */

//浏览器是如何规划同步异步机制的
/**
 * 1.浏览器是多线程的，js是单线程的（浏览器只给js执行分配一个线程）：单线程的特点就是一次只能处理一件事情
 *  进程：每一个应用程序都可以理解为一个进程（浏览器打开一个页面，就相当于
 *      开辟一个进程），在一个程序中（进程中）我们经常会同事干很多事情，此时
 *      我们可以分配多个线程去同时完成多项任务。
 *  2.js在单线程当中实现异步的机制，主要依赖于浏览器的任务队列完成的。浏览器中有两个任务队列（主任务队列、
 *  等待任务队列）
 */


let n = 0;
setTimeout(() => {
    console.log(++n)
}, 1000);
console.log(n);
while (1 == 1) {
    // 死循环了
}
/**
 * 主任务队列（自上而下执行js）                    等待任务队列：
 * 任务1：let n = 0;                                 [诞生一个异步的任务：1s执行方法]  
 *         
 * 任务2：设置定时器(同步)
 *      [诞生一个异步的任务：1s执行方法]  
 * 任务3：输出n => 0
 * 任务4：死循环（这个任务无法结束）
 * 
 * 
 * [注意]
 *  1.在主任务队列自上而下执行的时候，如果遇到一个异步操作任务，没有立即执行，而是把它放到等待任务队列中排队
 *  2.当主任务队列完成后才会到等待任务队列中进行查找（主任务队列完不成，不管等待任务队列中是否有到达时间的，
 *    都不处理，继续等待主任务队列完成，因为js是单线程的[一次只能处理一件事情]） 
 *  3.等待任务队列当中谁达到条件了（如果有很多都达到条件了，谁先达到的，就先处理谁），就把这个任务重新
 *    放到主任务队列中去执行，把这个任务执行完， 再去等待中去找....    
 */



setTimeout(() => {
    console.log(1)
}, 20);
console.log(2);
setTimeout(() => {
    console.log(3)
}, 10)
setTimeout(() => {
    console.log(4)
}, 100)
for (let i = 0; i < 9000000; i++) {

}
console.log(5)
/**
 * 2 5 3 1 4
 */



let n = 0;
setTimeout(() => {
    console.log(++n)
}, 0)
//定时器时间因子设置为0也不是立即执行，每个浏览器都有一个自己最小的等待和反应时间
// (谷歌：5~6，ie:10~13),所以写0还是异步编程
console.log(n)





setTimeout(() => {
    console.log(1)
}, 20);
console.log(2);
setTimeout(() => {
    console.log(3)
}, 10)
console.log(4)
for (let i = 0; i < 9000000; i++) {

}
console.log(5);
setTimeout(() => {
    console.log(6)
}, 8)
console.log(7)
setTimeout(() => {
    console.log(8)
}, 15)
console.log(9)

245793168